import{l as e,b as t,s as o}from"./index-Cnu_oIsx.js";function i(e){let t,o=e.length;for(;o>0;)t=Math.floor(Math.random()*o),o--,[e[o],e[t]]=[e[t],e[o]];return e}async function n({categoryId:e="mixed",questionCount:t=10,difficulty:i=null}){let n=o.from("questions").select("*").eq("is_active",!0);e&&"mixed"!==e&&(n=n.contains("question_tags",[{id:e}])),i&&(n=n.eq("difficulty",i)),n=n.limit(t);const s=performance.now(),{data:r,error:c}=await n,u=performance.now()-s;if(c)throw console.error("❌ [QuizService] Error fetching questions:",{message:c.message,details:c.details,categoryId:e,questionCount:t,difficulty:i,duration:`${u.toFixed(2)}ms`}),new Error(`FETCH_QUESTIONS_ERROR: ${c.message}`);return console.log("✅ [QuizService] Successfully fetched questions:",{count:r.length,categoryId:e,difficulty:i,duration:`${u.toFixed(2)}ms`}),r}async function s({userId:s,categoryId:r="mixed",questionCount:c=10,difficulty:u=null}){return e.setContext({userId:s,operation:"fetchQuestionsForUser"}),s?(e.info("Starting smart question fetch for user (using RPC)",{userId:s,categoryId:r,questionCount:c,difficulty:u}),await t("fetchQuestionsForUser",async()=>{try{const{data:t,error:a}=await o.rpc("get_unseen_questions",{p_user_id:s,p_category_id:"mixed"===r?null:r,p_difficulty:u,p_limit:2*c});if(a)return e.error("Error fetching unseen questions via RPC",{error:a}),e.warn("Falling back to basic fetch due to RPC error",{error:a.message}),console.error("[RPC ERROR] get_unseen_questions:",a),n({categoryId:r,questionCount:c,difficulty:u});if(!t||0===t.length)return e.warn("No unseen questions found, falling back to basic fetch"),n({categoryId:r,questionCount:c,difficulty:u});const f=i([...t]).slice(0,c);return e.success("Successfully fetched smart questions for user",{totalUnseen:t.length,selected:f.length,categoryId:r,difficulty:u}),f}catch(t){return e.error("Exception in fetchQuestionsForUser, falling back to basic fetch",{error:t.message,stack:t.stack}),n({categoryId:r,questionCount:c,difficulty:u})}})):(e.warn("No userId provided, falling back to basic fetchQuestions",{categoryId:r,questionCount:c,difficulty:u}),n({categoryId:r,questionCount:c,difficulty:u}))}async function r(t){const{categoryId:n,questionCount:s,difficulty:r,excludeQuestionIds:c=[]}=t;e.info("Fetching block questions",t);let u=o.from("questions").select("*").eq("is_active",!0);n&&"mixed"!==n&&(u=u.contains("question_tags",[{id:n}])),r&&(u=u.eq("difficulty",r)),c.length>0&&(u=u.not("id","in",`(${c.join(",")})`)),u=u.limit(s);const{data:a,error:f}=await u;if(f)throw e.error("Error fetching block questions",{error:f,blockConfig:t}),new Error(`FETCH_BLOCK_QUESTIONS_ERROR: ${f.message}`);const l=i([...a]);return e.success("Successfully fetched block questions",{count:l.length,blockConfig:t}),l}export{r as a,s as f};
