import{s as r}from"./index-McxExe4l.js";import"./vendor-react-DID6TU-8.js";import"./vendor-CCC68rl8.js";class e{static async fetchQuestions(e,t=10){try{let o=r.from("questions").select("\n          *,\n          question_tags!inner (\n            tag_id,\n            tags (\n              name,\n              type\n            )\n          )\n        ");"mixed"!==e&&(o=o.eq("question_tags.tag_id",e));const{data:s,error:n}=await o.limit(t);if(n)throw console.error("Supabase error fetching questions:",n),n;if(!s||0===s.length)throw new Error("No questions found for this category");return s.sort(()=>Math.random()-.5)}catch(o){throw console.error("Error fetching questions:",o),o}}static async fetchCategories(){try{const{data:e,error:t}=await r.from("tag_question_counts").select("*").eq("is_active",!0).order("order_index",{ascending:!0});if(t){console.error("Error fetching from tag_question_counts view:",t);const{data:e,error:o}=await r.from("tags").select("\n            id,\n            name,\n            slug,\n            description,\n            icon_name,\n            color,\n            color_code,\n            parent_id,\n            type,\n            order_index,\n            is_active,\n            created_at,\n            updated_at\n          ").eq("is_active",!0).order("order_index",{ascending:!0});if(o)throw o;return await Promise.all((e||[]).map(async e=>{const{count:t,error:o}=await r.from("question_tags").select("*",{count:"exact",head:!0}).eq("tag_id",e.id);return o&&console.warn(`Error counting questions for tag ${e.id}:`,o),{...e,question_count:t||0}}))}return e||[]}catch(e){throw console.error("Error fetching categories:",e),e}}static async createQuizSession(e,t,o){try{const{data:s,error:n}=await r.from("quiz_sessions").insert({user_id:e,quiz_type:"practice",total_questions:o,settings:{category_id:"mixed"!==t?t:null,is_mixed:"mixed"===t}}).select().single();if(n)throw console.error("Error creating quiz session:",n),n;return s}catch(s){throw console.error("Error creating quiz session:",s),s}}static async recordQuizResponse(e,t,o,s,n=0){try{const{error:i}=await r.from("quiz_responses").insert({session_id:e,question_id:t,selected_option_id:o,is_correct:s,response_order:n,time_spent_seconds:0});if(i)throw console.error("Error recording quiz response:",i),i}catch(i){throw console.error("Error recording quiz response:",i),i}}static async updateUserQuestionHistory(e,t,o,s){try{const{error:o}=await r.from("user_question_history").upsert({user_id:e,question_id:t,last_answered_correctly:s,last_seen_at:(new Date).toISOString()},{onConflict:"user_id,question_id"});if(o)throw console.error("Error updating user question history:",o),o}catch(n){throw console.error("Error updating user question history:",n),n}}static async completeQuizSession(e,t,o){try{const{error:s}=await r.from("quiz_sessions").update({correct_answers:o,completed_at:(new Date).toISOString()}).eq("id",e).eq("user_id",t);if(s)throw console.error("Error completing quiz session:",s),s}catch(s){throw console.error("Error completing quiz session:",s),s}}static async getUserProgress(e,t){if(!e||!t)return 0;try{const{data:o,error:s}=await r.from("user_question_history").select("\n          last_answered_correctly,\n          questions!inner (\n            question_tags!inner (\n              tag_id\n            )\n          )\n        ").eq("user_id",e).eq("questions.question_tags.tag_id",t);if(s)return console.warn("Error getting user progress:",s),0;if(!o||0===o.length)return 0;const n=o.filter(r=>r.last_answered_correctly).length,i=o.length;return Math.round(n/i*100)}catch(o){return console.error("Error getting user progress:",o),0}}static async testConnection(){try{const{data:e,error:t}=await r.from("tags").select("count(*)").limit(1);return t?{success:!1,error:t.message}:{success:!0,data:e}}catch(e){return{success:!1,error:e.message}}}}export{e as QuestionService};
